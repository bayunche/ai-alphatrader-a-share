我需要你帮我分析并调整后端逻辑，要求“从东方财富网页接口抓取 A 股主表信息 + 价格信息，并保存到本地 SQLite 数据库，同时支持定时只刷新价格字段”的。

⚠️重要要求（请严格遵守）：

==================== 1. 数据来源与接口（必须使用这些 URL，不要伪造） ====================

你必须使用东方财富网页实际使用的接口（push2 / push2his），不要伪造不存在的 API。

1）A 股主表（带基础行情字段，分页）：
    https://push2.eastmoney.com/api/qt/clist/get

2）单只股票实时行情：
    https://push2.eastmoney.com/api/qt/stock/get

3）单只股票历史 K 线：
    https://push2his.eastmoney.com/api/qt/stock/kline/get

如果你不确定其它接口，一律不要创造或假设新接口，只能用我给的这三个。

==================== 2. 接口参数与字段要求 ====================

【2.1】主表接口（clist/get）

- URL: https://push2.eastmoney.com/api/qt/clist/get
- 必须使用的参数值（不要擅自改）：
    fs = m:0+t:6,m:0+t:80,m:1+t:2,m:1+t:23   # A 股全市场（深A/创业板/沪A/科创）
    pz = 100                                  # 每页 100 条
    pn 从 1 开始递增，直到返回的 data.diff 为空或不存在，表示所有股票拉取完毕
    fields = f12,f13,f14,f2,f3,f4,f5,f6,f15,f16,f17,f18,f20,f21,f9,f23

- 请将这些字段映射为含义清晰的列名：
    f12 -> code           # 股票代码
    f13 -> market_id      # 市场ID
    f14 -> name           # 名称
    f2  -> last           # 最新价
    f3  -> chg_pct        # 涨跌幅（百分数，如 1.23 表示 1.23%）
    f4  -> chg            # 涨跌额
    f5  -> volume         # 成交量
    f6  -> amount         # 成交额
    f15 -> high           # 最高价
    f16 -> low            # 最低价
    f17 -> open           # 开盘价
    f18 -> pre_close      # 昨收价
    f20 -> total_mv       # 总市值
    f21 -> float_mv       # 流通市值
    f9  -> pe_dynamic     # 市盈率（动态）
    f23 -> pb             # 市净率

【2.2】实时行情接口（stock/get）

- URL: https://push2.eastmoney.com/api/qt/stock/get

- 必须使用的字段（通过 fields 参数指定）：
    f57,f58,f43,f60,f44,f45,f46,f47,f71,f168,f164

- 映射要求：
    f57 -> code
    f58 -> name
    f43 -> last        # 最新价 *100，需要 /100
    f60 -> pre_close   # 昨收价 *100，需要 /100
    f44 -> high        # 最高价 *100，需要 /100
    f45 -> low         # 最低价 *100，需要 /100
    f46 -> open        # 开盘价 *100，需要 /100
    f47 -> volume      # 成交量（股）
    f71 -> avg_price   # 均价 *100，需要 /100
    f168 -> turnover_rate   # 换手率（百分数，直接用）
    f164 -> volume_ratio    # 量比（直接用）

- ⚠️注意：f43,f60,f44,f45,f46,f71 这些价格字段返回值是 *100 的，请在代码中统一除以 100 还原为正常价格。

【2.3】K 线接口（kline/get）

- URL: https://push2his.eastmoney.com/api/qt/stock/kline/get

- secid 规则（非常关键）：
    深市股票：0.代码  （例如 000001 -> 0.000001）
    沪市股票：1.代码  （例如 600000 -> 1.600000）

- 请写一个函数 code_to_secid(code: str) 来做这个转换：
    以 '6' 开头的 6 位代码 → 1.代码
    其它 A 股代码 → 0.代码

- k线参数默认要求：
    klt = 101   # 日线
    fqt = 1     # 前复权
    beg = '0'   # 从最早开始
    end = '99999999'  # 直到最新

- 返回的 data.klines 是一个字符串数组，每一项格式类似：
    "日期,开盘价,收盘价,最高价,最低价,成交量,成交额,..."

- 请解析成 DataFrame，至少包含这几列：
    date, open, close, high, low, volume, amount

==================== 3. 数据库要求（SQLite） ====================

【3.1】数据库连接

- 使用本地 SQLite 数据库文件，例如 stock.db。
- 只能使用 Python 标准库 sqlite3 进行数据库操作，不要使用 SQLAlchemy 或其它 ORM。
- 在脚本顶部定义一个可配置的数据库文件路径，例如：

    DB_PATH = "stock.db"

- 然后通过 sqlite3.connect(DB_PATH) 获取连接。

【3.2】数据表设计（非常重要）

请用 sqlite3 执行建表语句，在数据库中创建两个表：

1）a_stock_master  —— 证券主表 + 最近一条价格信息

字段包括（SQLite 类型可以用 TEXT / INTEGER / REAL）：

- code          TEXT        主键
- market_id     INTEGER
- name          TEXT
- last          REAL        -- 最新价
- chg_pct       REAL
- chg           REAL
- volume        INTEGER
- amount        REAL
- high          REAL
- low           REAL
- open          REAL
- pre_close     REAL
- total_mv      REAL
- float_mv      REAL
- pe_dynamic    REAL
- pb            REAL
- last_updated  TEXT        -- 存 ISO 格式时间字符串，如 "2025-11-24 10:23:45"

其中 code 作为 PRIMARY KEY。

2）a_stock_kline_daily  —— 日线 K 线表（可选，但请写出来）

字段包括：

- id            INTEGER PRIMARY KEY AUTOINCREMENT
- code          TEXT        -- 股票代码
- date          TEXT        -- "YYYY-MM-DD"
- open          REAL
- close         REAL
- high          REAL
- low           REAL
- volume        REAL
- amount        REAL

并在 code + date 上创建唯一索引，例如：

CREATE UNIQUE INDEX IF NOT EXISTS idx_kline_code_date
ON a_stock_kline_daily(code, date);

【3.3】数据写入策略（关键）

- 初次全量拉取 A 股主表时：
    - 对于每只股票：
        - 如果 a_stock_master 中不存在该 code → 插入新记录
        - 如果已存在该 code → 更新所有字段（主表 + 价格字段）
    - 初次拉取后，a_stock_master 里应该包含全市场所有 A 股一条记录。

- 实时刷新价格时（重点）：
    - 只更新 a_stock_master 中的“价格相关字段 + last_updated”，即：
        last, chg_pct, chg, volume, amount, high, low, open, pre_close, total_mv, float_mv, pe_dynamic, pb, last_updated
    - 不要清空 / 改动 code, name, market_id 等静态信息。
    - 刷新逻辑可以根据 code 列表循环调用 stock/get 接口，逐条 UPDATE 对应记录。

- 对于 K 线数据：
    - code + date 作为唯一组合键，如果已存在该日期的记录就执行 UPDATE，否则 INSERT。
    - 可以使用 INSERT OR REPLACE 或者先查询后 UPDATE 的方式。

==================== 4. 功能函数设计要求 ====================

脚本中至少包含以下 Python 函数，并且要有清晰的函数签名与注释：

1）fetch_a_stock_list() -> pandas.DataFrame
    - 使用 clist/get 接口，分页拉取全部 A 股主表信息。
    - 返回的 DataFrame 至少包含：
      code, market_id, name, last, chg_pct, chg, volume, amount, high, low, open, pre_close, total_mv, float_mv, pe_dynamic, pb

2）init_db() -> None
    - 使用 sqlite3 创建数据库连接。
    - 创建 a_stock_master 和 a_stock_kline_daily 两张表（如果不存在则创建），以及 K 线的唯一索引。

3）save_master_to_db(df: pandas.DataFrame) -> None
    - 将 fetch_a_stock_list() 返回的主表 DataFrame 写入 a_stock_master 表。
    - 实现 upsert 逻辑：不存在则 INSERT，存在则 UPDATE。
    - 使用 sqlite3 的 INSERT OR REPLACE 或者先 SELECT 再 UPDATE 的方式实现，不要使用 ORM。

4）fetch_realtime_quote(code: str) -> dict
    - 调用 stock/get 接口。
    - 使用前文指定的字段映射与 /100 规则。
    - 返回一个包含：
        code, name, last, pre_close, high, low, open, volume, avg_price, turnover_rate, volume_ratio
      这些 key 的 dict。

5）refresh_realtime_quotes_in_db(codes: list[str]) -> None
    - 遍历 codes 列表，对每个 code 调用 fetch_realtime_quote。
    - 将对应记录的价格字段更新到 a_stock_master 表中，只更新价格相关字段 + last_updated。
    - 如果某个 code 在表中不存在，可以选择跳过或插入新记录（任选一种策略，但要在注释中说明）。

6）fetch_kline_history(code: str, beg: str = "0", end: str = "99999999") -> pandas.DataFrame
    - 调用 kline/get 接口，获取该股票的日线前复权历史数据。
    - 返回包含 date, open, close, high, low, volume, amount 的 DataFrame。

7）save_kline_to_db(code: str, df_kline: pandas.DataFrame) -> None
    - 将某个股票的日线数据保存到 a_stock_kline_daily 表中。
    - 通过 INSERT OR REPLACE 或者 code+date 先查后更的方式实现 upsert。

8）main() 示例
    - main 函数中演示以下流程：
        a) 调用 init_db() 初始化数据库和表结构。
        b) 调用 fetch_a_stock_list() 拉取全市场主表，并调用 save_master_to_db() 写入数据库。
        c) 从数据库中查询所有 code，示例性地对前 N 只股票调用 refresh_realtime_quotes_in_db() 刷新价格。
        d) 对某一只示例股票（例如 000001）调用 fetch_kline_history + save_kline_to_db。

